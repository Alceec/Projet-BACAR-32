"""This is a template for State Machine Modules

   A State Machine module is a python file that contains a  `loop` function.
   Similar to how an Arduino program operates, `loop` is called continuously:
   when the function terminates, it is called again.

   The `loop` function should continuously listens to messages generated by:
   - the path detector (concerning the path to follow),
   - the sign detector (concerning road signs detected, if any),
   - the remote command operator (concerning commands to start/stop driving,
     or do specific manoeuvers)
   - and the arduino controller of the physical car (concerning the current
     state; possible sensor readings, ...)

   and decide on how to drive the car correspondingly. See the description of
   the `loop` method below for more details.

   This simplistic State Machine responds to remote commands "GO", "STOP"
   and "TEST_COMM". In addition, it listens to path information from the
   Simplistic Path detector, and sends actuation commands that are
   compatible with the simulator.
"""


import logging
import time
from event import Event
from car import Car
import numpy as np
import random

# constants for the different states in which we can be operating
IDLE = 1
STOPPED = 2
MOVING = 3
# You can add other states here
c_right = 0
c_left = 0
c_stop = 0
path = None
m_path = None
angle = 0
StartTime = None
TimeInterval = 2
# Setup up the state machine. The following code is called when the state
# machine is loaded for the first time.
logging.info('Simplistic StateMachine has been initialized')

# The next variable is a global variable used to store the state between
# successive calls to loop()
state = IDLE
lock = "OFF"

def loop():
    '''State machine control loop.
    Like an arduino program, this method is called repeatedly: whenever
    it exits it is called again. Inside the function, call:
    - time.sleep(x) to sleep for x seconds (x can be fractional)
    - Event.poll() to get the next event (output of Path and/or Sign detector,
      status sent by the car, or remote command).
    - Car.send(x,y,u,v) to communicate two integers (x and y) and
      two floats(u,v) to the car. How the car interprets this message depends
      on how you implement the arduino nano. For the simulator, x, and y
      are ignored while u encodes the speed and v the relative angle to turn
      to.
    '''
    global state  # define state to be a global variable
    global c_left
    global c_right
    global c_stop
    global path
    global m_path
    global angle
    global StartTime
    global TimeInterval
    global lock
    event = Event.poll()
    if event is not None:
        if event.type == Event.CMD and event.val == "GO":
            # A command by the remote computer to start the car
            logging.info("remotely ordered to GO!")
            state = MOVING
            lock = "OFF"
        elif event.type == Event.CMD and event.val == "LOCK_LEFT":
            lock = "LEFT"
        elif event.type == Event.CMD and event.val == "LOCK_RIGHT":
            lock = "RIGHT"
        elif event.type == Event.CMD and event.val == "STOP":
            logging.info("remotely ordered to stop")
            emergency_stop()  # emergency_stop is further defined below
        elif event.type == Event.CMD and event.val == "TEST_COMM":
            # When it receives this command, the state machine sends a test
            # message to the Arduino. If the Arduino is programmed with
            # "testComm.ino", the LED of the Arduino will change its state and
            # the Arduino will send the message back. This can be seen in the
            # remote terminal that runs "start_car.py" as a logging message (see
            # Event.CAR below). For more info, see the sreencast describing
            # "testComm.ino".
            Car.send(5, -10, 3.14, -37.2)
        # Note that you can decide to act on  other evant.val value for events
        # of type Event.CMD!
        elif event.type == Event.PATH:
            # You received the PATH dictionary emitted by the path detector
            # you can access this dict by event.val
            # actuate car coresspondingly, change state if relevant
            if state == MOVING:
                path = event.val['headings']
            #logging.info('1')    
                if len(path) != 0 and lock == "OFF": #lock permet de tourner toujours dans le même sens si l'utilisateur l'ordonne
                    if m_path == None: #indexation de la route à suivre au tournant
                        if len(path) == 1:
                            angle = path[0]
                            Car.send(0,0,float(3*np.cos(0.8*angle/180*np.pi)),angle/5)
                        elif len(path) > 1:
                            """en l'abscence de panneaux,
                            évalue l'angle le plus proche de 0, si il est compris entre -15°
                            et 15°, le considère comme "continuer tout droit" et le choisit donc
                            comme stipulé dans les manoeuvres demandées, sinon choisit au hasard"""
                            index = 0
                            var_front = abs(path[index])
                            for i in range(len(path)-1):
                                if abs(path[i+1]) < var_front:
                                    index = i+1
                                    var_front = abs(path[index])
                            if var_front <= 15:
                                m_path = index
                            else:
                                m_path = random.randint(0, len(path)-1)
                            if c_left <= 2:
                                c_left = 0
                            elif c_left > c_right and path[-1] >= 15: #impose une limite de 15° être considéré comme une tournant gauche
                                m_path = -1
                                logging.info(m_path)
                                c_right = 0
                                c_left = 0
                            if c_right <= 2:
                                c_right = 0
                            elif c_left < c_right and path[0] <= -15: #impose la limite pour la droite
                                m_path = 0
                                c_right = 0
                                c_left = 0
                            if c_stop <= 2:
                                c_stop = 0
                            else:
                                state = STOPPED
                                Car.send(0,0,0,0)
                                c_stop = 0
                            angle = path[m_path]
                    else:
                        if len(path) == 1:
                            m_path = None
                    if m_path != None and state == MOVING:
                        """si on a au moins 2 angles, on garde en mémoire l'ancienne valeur
                        de l'angle qu'on a pris, et on redonne une nouvelle indexation, la 
                        plus proche possible de l'ancienne valeur dans la nouvelle liste"""
                        if len(path) >= 2:
                            index = 0
                            var_angle = abs(path[index]-angle)
                            for i in range(len(path)-1):
                                if abs(path[i+1]-angle) < var_angle:
                                    index = i+1
                                    var_angle = abs(path[index]-angle)
                            m_path = index
                        logging.info(m_path)
                        angle = path[m_path]
                        Car.send(0,0,float(3*np.cos(0.8*angle/180*np.pi)),angle/5)
                elif len(path) != 0:
                    if lock == "RIGHT":
                        angle = path[0]
                        Car.send(0,0,3*np.cos(angle/180*np.pi),angle)
                    elif lock == "LEFT":
                        angle = path[-1]
                        Car.send(0,0,3*np.cos(angle/180*np.pi),angle)
                elif len(path):
                    Car.send(0,0,0,angle)
            elif state == STOPPED: #state uniquement possible grace au panneau stop, attends deux secondes quand elle voit un virage
                if StartTime == None:
                    StartTime = time.time()
                if time.time() > StartTime + TimeInterval:
                    logging.info("Done")
                    StartTime = None
                    state = MOVING
                       

        elif event.type == Event.SIGN:
            # You received the SIGN dictionary emitted by the sign detector
            # you can access this dict by event.val
            # actuate car coresspondingly, change state if relevant            
            sign = event.val['sign']

            if m_path == None and lock == "OFF":
                if sign == "LEFT":
                    c_left += 1
                if sign == "RIGHT":
                    c_right += 1
                if sign == "STOP!":
                    c_stop += 1

        elif event.type == Event.CAR:
            # You received a message from the arduino that is operating the car
            # In this case, event.val contains a dictionary with keys x,y,u,v
            # where x and y are ints; u,v, are floats.
            # Act on this message depending on how you implemented the arduino
            # (e.g., is the arduino sending that there is an obstacle in front
            # and you should stop ?)
            logging.info("Received CAR event with x=%d, y=%d, u=%f, v=%f" %
                (event.val['x'], event.val['y'], event.val['u'], event.val['v']))
            if event.val['y'] == 'l':
                lock = "ON"
            elif event.val['y'] == 'u':
                lock = "OFF"


def emergency_stop():
    global state
    state = IDLE
    Car.send(0, 0, 0.0, 0.0)
        
