"""This is a template for State Machine Modules

   A State Machine module is a python file that contains a  `loop` function.
   Similar to how an Arduino program operates, `loop` is called continuously:
   when the function terminates, it is called again.

   The `loop` function should continuously listens to messages generated by:
   - the path detector (concerning the path to follow),
   - the sign detector (concerning road signs detected, if any),
   - the remote command operator (concerning commands to start/stop driving,
     or do specific manoeuvers)
   - and the arduino controller of the physical car (concerning the current
     state; possible sensor readings, ...)

   and decide on how to drive the car correspondingly. See the description of
   the `loop` method below for more details.

   This simplistic State Machine responds to remote commands "GO", "STOP"
   and "TEST_COMM". In addition, it listens to path information from the
   Simplistic Path detector, and sends actuation commands that are
   compatible with the simulator.
"""

import numpy as np 
import logging
import time
from event import Event
from car import Car
import pygame
import pandas as pd
import time
import cv2 


# Setup up the state machine. The following code is called when the state
# machine is loaded for the first time.
logging.info('Simplistic StateMachine has been initialized')


class Memory_Replay: 
    def __init__(self, Max_size) : 
        self.buffer = []
        self.max_size =Max_size
    
    def add(self, memory) : 
        
        if len(self.buffer) == self.max_size : 
            self.buffer.pop(0) 

        self.buffer.append(memory) 

        if len(self.buffer) > self.max_size :
          raise Exception('overflow')

def One_Hot(letter) : 
  if letter == 'a' : 
    return [1, 0, 0]
  elif letter == 'w': 
    return [0, 1, 0]
  elif letter == 'd' : 
    return [0,0,1]
  else : 
    raise Exception("unaccepted command") 




first = True


pygame.init()
screen = pygame.display.set_mode((100, 100))
direction = 0 
command = "w"
#Path_name = None
max_len = 20 
memory = Memory_Replay(max_len) 
sign = None
 
timer = 0 
step = 0 

data = {"w" : pd.DataFrame(columns=['command', 'distances', 'sign']), 
        "a" : pd.DataFrame(columns=['command', 'distances', 'sign']), 
        "d" : pd.DataFrame(columns=['command', 'distances', 'sign'])}

Car.send( 0, 0, 2., 0) 

frame = 0 

registering = False 

def loop():

    global state
    global first
    global command
    #global Path_name
    global memory
    global timer 
    global data
    global direction 
    global sign
    global step 
    global frame 
    global registering
    global max_len

    time_offset = .3 
  

    if first :
        first = False


    for event in pygame.event.get():
        if event.type == pygame.KEYDOWN and event.key <= 256:
          if chr(event.key) == 'a' : 
            Car.send(0, 0, 2., 2) 
          elif chr(event.key) == 'd' : 
            Car.send(0, 0,  2., -2) 
          elif chr( event.key ) == 's': 
            Car.send(0, 0, -2 , 0)
          command = chr(event.key) 
          
          if chr(event.key) == ' ' : 
            command = 'w'

        if event.type == pygame.KEYUP : 
          if chr(event.key) == " " : 
            registering = True
          else : 
            Car.send(0, 0, 5., 0.) 
            command = 'w'


    event = Event.poll()
    if event is not None and registering :

        if event.type == Event.PATH:
            tmp = event.val 
            
            #    LSTM
            distance = tmp['distance'] 
            distance.append(sign) 
            if(distance[-1] == 150 or distance[-1] == -150) : 
              print("SIGN REGISTERED")
            memory.add(distance)
            

            step += 1


            if len(memory.buffer) >= max_len : 
              if len(data[command].index) == 0 :
                logging.info("new Dataframe")  
                data[command].loc[0] = \
                  {'command' : One_Hot(command), 'distances':np.array(memory.buffer), 'sign': sign}
              else : 
                data[command].loc[data[command].index[-1] + 1] = \
                  {'command' : One_Hot(command), 'distances':np.array(memory.buffer), 'sign': sign}

              if step % 10 == 0 : 
                data['a'].to_json('NN_data/Data/A/manhattan.json')
                data['w'].to_json('NN_data/Data/W/manhattan.json') 
                data['d'].to_json('NN_data/Data/D/manhattan.json') 

              sign = 0 

        elif event.type == Event.SIGN:

            tmp = event.val
            if not tmp['sign'] == None : 
                logging.info(tmp['sign']) 

            if tmp['sign'] == 'LEFT' : 
              sign = -150 
            elif tmp['sign'] == 'RIGHT' : 
              sign = 150 
            elif 'STOP' in tmp['sign'] : 
              sign = 0 
            elif tmp['sign'] == None : 
              sign = 0 
    




